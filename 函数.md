# 	函数

## None类型

- 思考:如果函数没有使用`return`语句返回数据，那么函数有返回值吗?

  ——实际上是:有的。

- Python中有一个特殊的字面量:None，其类型是:`<class 'NoneType'>`无返回值的函数，实际上就是返回了: `None`这个字面量

- `None`表示:空的、无实际意义的意思

- 函数返回的`None`就表示这个函数没有返回什么有意义的内容。也就是返回了空的意思

  > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221118192925622.png" alt="image-20221118192925622" style="zoom:50%;" />

  - **上例中说明None可以程序员手动在函数中写明返回，也可以省略**



- **应用场景：**

  1. **用在函数无返回值上**
  2. **用在if判断上**

  - 在if判断中，None等同于False

  - 一般用在函数中主动返回None，配合if判断做相关处理

    ```python
    def check_age(age):
    	if age > 18:
    		return "SUCCESS"
    	else:
    		return None #该句省略则编译器也会自动返回None
    
    result = check_age(age)
    if not result:	# not表示取反，如若result为None即False，则not result为True
    	print("未成年，不可以进入！")
    ```

  3. **用在声明无内容的变量上**

     定义变量，但暂时不需要变量有具体值，可以用None来代替

     ```Python
     name = None
     ```

  4. **总结**

<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221118194509696.png" alt="image-20221118194509696" style="zoom:50%;" />

## 函数说明文档

> **以下绿色部分为函数说明文档**

![image-20221119185232463](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119185232463.png)

> **鼠标悬停至函数调用处括号（）时，会浮现函数的说明文档，如下图所示**

![image-20221119185216175](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119185216175.png)

## global关键字

- 使用global关键字可以在**函数内部声明变量为全局变量**

```Python
num = 100 # 全局变量

def func1():
    global num  # 说明num是全局变量（而且是前面已经定义的全局变量），此句代码一写，函数里的num和函数外的num就是同一个了
    num = 200   # 将全局变量修改为200,此时会修改上面的全局变量num
    # global num = 200 # 不能这样同时声明num为全局变量又赋值
    print(num)  # 输出200

func1()
print(num)  # 输出200
```



## 多返回值函数

### 问题引入

> <img src="E:\Typora\Image\image-20221130152237180.png" alt="image-20221130152237180" style="zoom: 33%;" />

但是我就是想返回多个返回值，怎么办呢？接下来看看多返回值的函数的定义和使用

### 定义语法和使用

> <img src="E:\Typora\Image\image-20221130152450812.png" alt="image-20221130152450812" style="zoom: 33%;" />

> <img src="E:\Typora\Image\image-20221130152544652.png" alt="image-20221130152544652" style="zoom:50%;" />

#### 多个返回值的类型不受限

> <img src="E:\Typora\Image\image-20221130152629138.png" alt="image-20221130152629138" style="zoom:50%;" />



## 函数的多种传参方式 

### 函数的多种传参方式总览***

> <img src="E:\Typora\Image\image-20221130164025162.png" alt="image-20221130164025162" style="zoom: 50%;" />



### 位置传参(位置形参)

> <img src="E:\Typora\Image\image-20221130153328607.png" alt="image-20221130153328607" style="zoom:33%;" />



### 关键字传参

> ![image-20221130153841127](E:\Typora\Image\image-20221130153841127.png)

#### 注意

> **位置传参与关键字传参混用时：**
>
> 1. 位置传参必须在关键字传参之前，并且需要和函数的形参位置匹配
>
> 2. 关键字传参则不需要与函数形参位置匹配
>
>     ```python
>     def user_info(name, age, gender):
>         print(f"您的名字是:{name},年龄是:{age},性别是:{gender}")
>                                             
>     user_info("梁深南", gender="男", age = 20)	# 关键字传参不需要与函数形参位置匹配，即可不按照固定顺序			
>     ```

> 演示案例：
>
> ![image-20221130154437525](E:\Typora\Image\image-20221130154437525.png)



### 缺省传参（默认值形参）

> ![image-20221130154705783](E:\Typora\Image\image-20221130154705783.png)

#### 注意

> **位置形参不能在默认值形参之后**
>
> ![image-20221130155657670](E:\Typora\Image\image-20221130155657670.png)
>
> 以下情况也一样，**默认值形参夹在位置形参中间也不行**
>
> ```python
> def user_info(name, age = 11, gender):
>     print(f"您的名字是:{name},年龄是:{age},性别是:{gender}")
> ```
>
> ![image-20221130155943713](E:\Typora\Image\image-20221130155943713.png)



### 不定长传参（不定长参数）

> ![image-20221130160221098](E:\Typora\Image\image-20221130160221098.png)



#### 不定长的位置传参

> ![image-20221130160849055](E:\Typora\Image\image-20221130160849055.png)

##### 不定长的位置传参的形参默认命名规范

如果不定长的位置传参的形参名没有特别的含义需要，一般命名为`*args`



##### 应用案例

> <img src="E:\Typora\Image\image-20221130161331264.png" alt="image-20221130161331264" style="zoom:50%;" />

不定长的位置传参，其传递到函数后内部后会将参数转为元组`tuple`类型



#### 不定长的关键字传参

> ![image-20221130161032912](E:\Typora\Image\image-20221130161032912.png)



##### 不定长的关键字传参的形参默认命名规范

如果不定长的关键字传参的形参名没有特别的含义需要，一般命名为`**kwargs`(kw：keyword)



##### 注意：不定长的关键字传参必须是`键 = 值`的形式

> ![image-20221130162125755](E:\Typora\Image\image-20221130162125755.png)
>
> 不定长的关键字传参**如果不以`键 = 值`的形式进行传递，编译器会报错**



##### 应用案例

> ![image-20221130162436328](E:\Typora\Image\image-20221130162436328.png)

##### 不定长的关键字传参，其传递到函数后内部后会将参数转为字典`dict`类型



## 匿名函数

### 函数作为参数传递

> <img src="E:\Typora\Image\image-20221201221713380.png" alt="image-20221201221713380" style="zoom:50%;" />

> ![image-20221201223412447](E:\Typora\Image\image-20221201223412447.png)

> ​	<img src="E:\Typora\Image\image-20221201223526768.png" alt="image-20221201223526768" style="zoom:50%;" />



#### 注意

1. 这里函数作为参数传递，并不是我们其它编程语言中所认为的：在函数调用时，其他函数作为函数调用的参数；

    Python中是在函数定义时，就将其他函数作为函数的形参。



2. 函数作为参数传递，相当于函数内部的执行逻辑是不确定的，而**数据可能是确定**的，所以需要我们传递的是代码执行的逻辑；

    数据作为参数传递时，如上图中右上角定义的`add`函数，其函数内部执行的逻辑是确定的，而数据却是不确定的，所以需要我们传递的是数据。

> 如下图就是在：传递不同的代码执行逻辑
>
> ![image-20221201222152667](E:\Typora\Image\image-20221201222152667.png)
>
> 数据是确定的，上面三个例子都是`1`和`2`，但是传入的逻辑不一样。



3. 仿照上面`2`中的例子，当我们只写了函数头，括号中写了`compute`时，此时编译器是在那时不知道`compute`是函数名还是变量名的

> ​	![image-20221201222448000](E:\Typora\Image\image-20221201222448000.png)

​		只有当我们完善了后续的函数体，编译器才知道我们在`()`写的`compute`是个函数名：	

> ​	![image-20221201223012304](E:\Typora\Image\image-20221201223012304.png)



4. **上例中在定义的`test_func`函数时，实际上其括号中的形参名不需要与外部待传入函数名一致，如下图中的代码：**

> ![image-20221201224028680](E:\Typora\Image\image-20221201224028680.png)
>
> 上图中我们将原本在定义`test_func`函数时括号中的`compute`换成了`fun`，由上图的代码我们可以知道：
>
> - 起决定性作用的是当我我们调用`test_func`函数时括号内传递的函数名
>
> - 另外本例中还可以注意到函数也是由类型的，其类型是`function`



5. **实际上，上例中定义`test_func`函数时括号中的形参不仅可以是函数，还可以是变量，如下图中的代码：**

> ![image-20221201230041413](E:\Typora\Image\image-20221201230041413.png)



###  lambda匿名函数

#### 前言

> ![image-20221201224902194](E:\Typora\Image\image-20221201224902194.png)



#### 定义语法

![image-20221201224928990](E:\Typora\Image\image-20221201224928990.png)

##### 注意

1. `lambda`后紧跟是形参列表，既然是形参列表，其相关要求就需要符合形参列表的规则，同样其相关可以实现的多种传参方式也可以实现（该部分内容目前还未做过实践，后面有相关项目实战时务必进行学习和应用！）
2. 函数体只能写一行代码，不能换行，换行会报错





#### 应用案例

> ![image-20221201225153644](E:\Typora\Image\image-20221201225153644.png)
>
> **注意**
>
> 1. 上图中第二部分代码使用了`lambda`匿名函数，对比第一部分代码，以及参照`lambda`函数的定义语法，我们知道其没有返回语句，但实际上`lambda`是默认直接`return`函数体的。
>
> - 在本例中即相当于有`return x + y`在`lambd`匿名函数中存在
> - 如果对照`lambda`函数的定义语法，就是说会默认有`return 函数体`存在



#### 适用场景（自归纳总结）

1. **`lambda`匿名函数一般多用于要需要同时传入执行逻辑和数据的函数，其主要功能就是说明代码的执行逻辑**

> ![image-20221201232241217](E:\Typora\Image\image-20221201232241217.png)
>
> 如上图中的代码，`lambda`匿名函数就是用于传入给`test_func`代码的执行逻辑



2. 另外`lambda`匿名函数也可用于只需要传入执行逻辑的函数

> ![image-20221201231614650](E:\Typora\Image\image-20221201231614650.png)
>
> 上图中的代码，`test_func1`已经有自己的数据，只需要传入函数的执行逻辑，此时`lambda`匿名函数发挥的正是这个作用







# 数据容器

**一种可以存储多个元素的Python数据类型**

数据容器根据特点的不同，如：

- 是否支持重复元素
- 是否可以修改
- 是否有序

可分为5类，分别是：

> 1. **列表（list）**
>
> 2. **元组（tuple）**
>
> 3. **字符串（str）**
>
> 4. **集合（set）**
>
> 5. **字典（dict）**



## 列表`list()`[]

### **定义语法**

```python
# 字面量
[元素1，元素2，元素3，元素4，元素5...]

# 定义变量
变量名 = [元素1，元素2，元素3，元素4，元素5...]

# 定义空列表
变量名 = []
变量名 = list()
```

列表内的每一个数据，称之为元素

- 以 [ ] 作为标识
- 列表内的每一个元素之间用","逗号隔开



### 列表的特点

![image-20221123235111257](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123235111257.png)



### 列表的下标索引

#### **正向索引**

​	与数组类似，如下图：

![image-20221123205034914](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123205034914.png)



#### **反向索引**

![image-20221123205230318](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123205230318.png)

所以如果要找列表的最后一个元素，则可以直接`list[-1]`



#### **嵌套列表下表索引**

​	类似于二维数组

![image-20221123205352908](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123205352908.png)



- **如果列表索引越界**，如下代码所示：

```python
my_list = [1, 2, 3]
print(mylist[3])
```

则程序会抛异常如下：

> IndexError: list index out of range

![image-20221123205819213](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123205819213.png)





## ***列表的方法总览

![image-20221123234915625](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234915625.png)

### 列表的查询功能（方法）

（类中的函数称为方法）

- 查找指定元素在列表的下标，如果找不到，报错ValueError

语法：

```python
列表.index(要查找的元素)
```

- index()就是列表对象（变量）内置的方法
- 注意index()查找成功后返回值是第一个对应元素值的元素的小标（后续如果还要相同元素值的元素是无法获知的）



### 列表的修改功能

#### 修改特定位置（索引）的元素值

![image-20221123232813859](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123232813859.png)



#### 插入元素

![image-20221123233000702](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233000702.png)



#### 追加元素

1. 单元素追加

    > ![image-20221123233050993](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233050993.png) 	

2. 多元素追加

    > ![image-20221123233352902](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233352902.png)



#### 删除指定下标的元素

> ![image-20221123233548346](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233548346.png)
>

需要注意`pop()`方法实际上是将列表中的元素取出作为返回值（只不过取出的同时会在原列表中删除对应的元素），如下图

> ![image-20221123233915393](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233915393.png)
>
> 注意如果`pop()`括号中不传入元素的下标参数，则默认`pop`列表的最后一个元素





#### 删除指定元素值的元素

从左到右去搜索对应元素值的元素，第一个找到的元素将被删除

> ![image-20221123234206811](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234206811.png)
>

#### 清空列表

> ![image-20221123234405645](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234405645.png)
>



### 统计元素个数

1. 统计列表中指定元素值的元素个数

> ![image-20221123234520336](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234520336.png)
>

2. 统计列表元素个数


> ![image-20221123234736062](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234736062.png)
>



### 列表的遍历

遍历：将容器内的元素依次取出，并处理

遍历列表元素的方式（两种）：

### while循环遍历

> ![image-20221124000744858](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124000744858.png)
>



### for循环遍历

> ![image-20221124001048442](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124001048442.png)
>



### while和for循环的对比

> ![image-20221124001306506](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124001306506.png)
>

 

## 元组`tuple()`()

元组的理解：只读的列表list

> ![image-20221124182905702](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124182905702.png)

#### **元组内容不可被修改**

> ![image-20221124185707894](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124185707894.png)

#### **但元组中的列表list的内容可以修改**

> ![image-20221124185806502](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124185806502.png)



### 定义语法

```Python
# 定义元组字面量
(元素, 元素,......, 元素)

# 定义元组变量
变量名称 = (元素, 元素,......, 元素)

# 定义空元组
变量名称 = ()		# 方式1
变量名称 = tuple()	# 方式2
```



#### 注意

定义只有单个元素的元组时，要在第一个元素后跟一个逗号，否则无法构成单个元素的元组

```python
t1 = ("hello")							  	 # 单个元素，无逗号
print(f"t1的类型是{type(t1)},t1的内容是{t1}")	# 输出：t1的类型是<class 'str'>,t1的内容是hello
```

```python
t2 = ("hello", )							 # 单个元素，有逗号
print(f"t2的类型是{type(t2)},t2的内容是{t2}")	# 输出：t2的类型是<class 'tuple'>,t2的内容是('hello',)
```



#### 嵌套定义

如下：

> ![image-20221124184709214](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124184709214.png)

其输出结果是：

> ![image-20221124184741137](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124184741137.png)



### 元组的特点

> ![image-20221124185959462](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124185959462.png)

> ![image-20221124190344660](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124190344660.png)



### 下标索引

> ![image-20221124184846129](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124184846129.png)

同样的元组也可以通过[-1]这样的反向索引



### 元组的方法总览

> ![image-20221124184951846](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124184951846.png)
>
> 



### 元组的遍历

> ![image-20221124185252456](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124185252456.png)
>
>  



## 字符串""

> ![image-20221124191417166](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124191417166.png)



### 下标索引

> ![image-20221124191455879](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124191455879.png)



### 字符串内容无法修改

> ![image-20221124191829543](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124191829543.png)

> ![image-20221124191642163](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124191642163.png)

**如果必须要做，只能得到一个新的字符串，旧的字符串是无法修改的！！！**



### 字符串的特点

> ![image-20221124195111099](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124195111099.png)





### ***字符串的方法总览

![image-20221124194843614](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124194843614.png)





### 字符串查找功能`index`

> ![image-20221124192008237](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124192008237.png)

注意`index()`返回的是待查找字符串的第一个匹配字符在字符串中的位置（空格也算一个字符）

```python
# 如果字符串是中文也是一样
t1 = "我是 周杰伦"
print(t1.index("周杰伦"))	# 输出3
```



### 字符串的替换`replace`

> ![image-20221124192420603](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124192420603.png)

而且要注意，如果字符串里如果有多个重复的字符串1，那么这些所有的字符串1都会被替换成字符串2

并且，字符串在执行`replace()`之后本身是没有发生变化的：

```python
string = "itheima and itcast"
newString = string.replace("it", "程序")
print(newString)	# 输出：程序heima and 程序cast
print(string)		# 输出：itheima and itcast
```





### 字符串的分割`split`

#### **字符串经分割之后得到的是列表**

> ![image-20221124193015664](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193015664.png)

> ![image-20221124193146862](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193146862.png)
>
> 输出结果：
>
> ![image-20221124193224338](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193224338.png)

> ![image-20221124193259345](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193259345.png)

#### **注意**

1. `split()`的括号中如果不填入参数，则默认以空格作为分割符

2. `split()`方法不会改变原字符串



 

### 字符串的规整操作`strip()`

`strip()`中若不填入**规整符**，**默认规整空格和回车换行符**（即去掉前后空格和换行符）

#### 无参规整

> ![image-20221124193559085](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193559085.png)
>
> **无参数传入时可以去掉的不仅是开头和结尾空格，换行符`\n`也会被去掉**



#### 有参规整

> ![image-20221124193827724](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193827724.png)
>
> **此处应注意**虽然我们要求去掉的是首尾的"12"，即strip("12")，但strip()方法在执行时相当于把"12"，拆分成了"1"、"2"，所以这就导致只要首尾有符合的，就会被去掉，所以可以看到该例字符串尾部的21也被去掉了





### 字符串的统计(count、len)

- **count()方法**

> ![image-20221124194515646](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124194515646.png)
>
> 字符串中的`count()`方法不仅可以统计单个元素，还可以统计子串



- **len()函数**

> ![image-20221124194734759](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124194734759.png)





### 字符串的遍历

![image-20221124194940253](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124194940253.png)





## 序列

> ![image-20221125190721509](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125190721509.png)



### 序列的常用操作——切片

> 示意图：
>
> ![image-20221125190907797](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125190907797.png)
>
> 从大序列里面取出一个小序列



#### 操作语法

> ![image-20221125193320986](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125193320986.png)

> ![image-20221125191129368](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125191129368.png)



#### **注意**

1. **切片操作不会影响原序列，而是会得到一个新的序列（列表、元组、字符串）**

2.  **切片操作之后所获得的序列类型与原来的序列类型相同（列表、元组、字符串）**



#### 省略步长的情况

> ![image-20221125192330508](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192330508.png)

> ![image-20221125192809918](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192809918.png)



#### 省略起始下标和结束下标的情况

> ![image-20221125192422698](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192422698.png)Q

> ![image-20221125192859968](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192859968.png)



#### 省略起始下标，结束下标和步长的情况

注意此时方括号[]内要有冒号":"

> ![image-20221125191814966](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125191814966.png)

> ![image-20221125192837072](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192837072.png)



#### 步长为-1，省略起始下标和结束下标的情况

步长为-1时，序列的切片会从后往前进行

> ![image-20221125192522201](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192522201.png)

> ![image-20221125192920247](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192920247.png)



#### 步长为-1，不省略起始下标和结束下标的情况

> ![image-20221125193036439](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125193036439.png)

> ![image-20221125193109309](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125193109309.png)



#### 连续切片操作

> ![image-20221125194206124](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194206124.png)

> ![image-20221125194214608](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194214608.png)



#### 综合的一个方法/操作使用案例

> ![image-20221125194600078](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194600078.png)

> ![image-20221125194543773](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194543773.png)

> ![image-20221125194614188](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194614188.png)

可以看到，切片操作可以实现字符串的反转和切取特定片段，而无需将字符串转换成其他类型的数据容器。



## 集合`set`{}

### 为什么要使用集合

> ![image-20221126193801283](E:\Typora\Image\image-20221126193801283.png)



### 集合的特点

> ![image-20221126202030575](E:\Typora\Image\image-20221126202030575.png)



### 定义语法

> <img src="E:\Typora\Image\image-20221126193942251.png" alt="image-20221126193942251" style="zoom:50%;" />



**注意：定义空集合时不要用下面的语法**

```python
my_Set = {}
```

这样一来我们执行下面的程序时:

```python
print(my_Set)		# 输出：{}
print(type(my_Set))	# 输出：<class 'dict'>
```

可以看到此时`my_Set`并不是`set`类型，而是`dict`字典类型



### 集合具有去重和无序特性

> ![image-20221126194552017](E:\Typora\Image\image-20221126194552017.png)

上面的代码中我们可以看到，`my_set`中重复的元素被自动删除了，并且元素是无序的（我们定义该集合的时候第一个元素是`'传智教育'`，但是当我们print输出的时候第一个元素却变成了`'黑马程序员'`）



### 集合不是序列，不可通过下标访问



### 集合的修改

#### 添加新元素(`add(元素值)`)

> ![image-20221126195046760](E:\Typora\Image\image-20221126195046760.png)

#### 移除元素(`remove(元素值)`)

> ![image-20221126195342746](E:\Typora\Image\image-20221126195342746.png)

#### 随机取出元素(`pop()`)

> ![image-20221126195457675](E:\Typora\Image\image-20221126195457675.png)

该功能注意与列表的`pop()`进行区分：

列表的`pop()`方法是可以在括号内传入指定的元素下标进行元素取出操作的，但是集合由于无序，即没有下标，所以无法指定下标，所以集合中的`pop()`方法只能**随机取**集合中的一个元素出来。比如以下代码：

```python
my_Set = {"我", "是", "南"}
print(my_Set.pop())
```

> 第1次执行时的结果是：是
>
> 第2次执行时的结果是：是
>
> 第3次执行时的结果是：我
>
> 第4次执行时的结果是：我
>
> 第5次执行时的结果是：我
>
> 第6次执行时的结果是：是
>
> 第7次执行时的结果是：我	
>
> 第8次执行时的结果是：我
>
> 第9次执行时的结果是：我
>
> 第10次执行时的结果是：南

可以见得其随机性。



#### 清空集合(`clear()`)

> ![image-20221126200551179](E:\Typora\Image\image-20221126200551179.png)



#### 取出两个集合的差集(`difference`)

> ![image-20221126200804905](E:\Typora\Image\image-20221126200804905.png)



#### 消除两个集合的差集(`difference_update`)

> ![image-20221126201312944](E:\Typora\Image\image-20221126201312944.png)



#### 两个集合合并(`union`)

> ![image-20221126201419779](E:\Typora\Image\image-20221126201419779.png)



### 集合元素个数统计(`len()`)

> ![image-20221126201643269](E:\Typora\Image\image-20221126201643269.png)



### 集合的遍历

> ![image-20221126201750231](E:\Typora\Image\image-20221126201750231.png)
>
> 代码运行结果：
>
> ![image-20221126201829214](E:\Typora\Image\image-20221126201829214.png)



### 集合方法的方法总览

> ![image-20221126201943308](E:\Typora\Image\image-20221126201943308.png)



# 字典`dict`{}

## 为什么使用字典

> ![image-20221127213359109](E:\Typora\Image\image-20221127213359109.png)

> ![image-20221127213423941](E:\Typora\Image\image-20221127213423941.png)

> ![image-20221127213507698](E:\Typora\Image\image-20221127213507698.png)

## 使用字典的原因

可以使用字典，实现Key取出Value的操作



## 定义语法

> ![image-20221127213705894](E:\Typora\Image\image-20221127213705894.png)



## 字典的特点

> ![image-20221127225750345](E:\Typora\Image\image-20221127225750345.png)



## 注意事项

### 不能定义重复的`Key`

> ![image-20221127214755617](E:\Typora\Image\image-20221127214755617.png)

定义重复`Key`的会只有一个`Key`保存，且是最后一个**（这里是因为较后面的字典元素覆盖了前面的字典元素）**。

理解：相当于我们的字典当中，“字”只会有一个。



### 字典没有下标索引

字典(`dict`)和集合一样(`set`)，不可用使用下标索引。

但字典可以通过`Key`值来取得对应的`Value`值



### `Key`的类型不能是字典

字典的`Key`可以是除**了字典之外**的任何类型，`Value`可以是任何类型



### for循环遍历字典时，遍历变量得到的是每个字典元素的Key，而非每个字典元素

```python
my_dict = {"梁深南": 96, "周杰伦": 98, "张学友": 88}
for i in my_dict:	# i是所谓的遍历变量
    print(i)
```

输出结果：

> 梁深南
> 周杰伦
> 张学友



### 字典可能是有序的...

> ![image-20221127223507589](E:\Typora\Image\image-20221127223507589.png)

（还不太确定...）如果真的是有序的，那么就与集合有区别了，不过好像有序无序都没啥区别，因为没有办法用下标索引，只能通过`Key`索引，所以在这个角度来看，有序无序显得不是很有区分的必要





## 字典数据(`Value`)的获取

**与下标索引的方式非常类似**，但是`[]`中填入的是`Key`，不能是下标值

> ![image-20221127221017385](E:\Typora\Image\image-20221127221017385.png)

理解：汉字字典中找到某一个字(`Key`)就能看到其对应的含义(`Value`)





## 字典的嵌套

### 定义

> ![image-20221127222159546](E:\Typora\Image\image-20221127222159546.png)

> ![image-20221127222322422](E:\Typora\Image\image-20221127222322422.png)

 

### 使用

> ![image-20221127222548631](E:\Typora\Image\image-20221127222548631.png)



## 字典的修改

### 新增元素(`字典[Key] = Value`)

> ![image-20221127222915059](E:\Typora\Image\image-20221127222915059.png)
>
> 这个语法的使用前提是`[]`中输入的`Key`是原字典中不存在的



### 更新元素(`字典[Key] = Value`)

语法与**新增元素**的**语法相同**

> ![image-20221127223152677](E:\Typora\Image\image-20221127223152677.png)



### 删除元素(`pop(Key)`)

> ![image-20221127223751779](E:\Typora\Image\image-20221127223751779.png)
>
> 注意`pop(Key)`返回值是`Key`对应的`Value`值



### 清空元素(`字典.clear()`)

> ![image-20221127224127869](E:\Typora\Image\image-20221127224127869.png)



## 获取字典全部Key(`字典.keys()`)

> ![image-20221127224254254](E:\Typora\Image\image-20221127224254254.png)

理解：获取中华字典中全部的字

**用途：实现字典的遍历**

> 使用案例如下：
>
> ![image-20221129000047241](E:\Typora\Image\image-20221129000047241.png)

> ![image-20221129000128525](E:\Typora\Image\image-20221129000128525.png)





## 遍历字典

### for循环遍历方式一

> ![image-20221127224533173](E:\Typora\Image\image-20221127224533173.png)

> ![image-20221127224608764](E:\Typora\Image\image-20221127224608764.png)



### for循环遍历方式二

> ![image-20221127224721942](E:\Typora\Image\image-20221127224721942.png)
>
> `my_dict`虽然是字典类型，但此时key每一次取出来的都会是`my_dict`中的`key`而已，不会是字典元素
>
> 比如下面的代码：
>
> ```python
> my_dict = {"梁深南": 96, "周杰伦": 98, "张学友": 88}
> for i in my_dict:
>     print(i)
> ```
>
> 其输出结果为：
>
> > 梁深南
> > 周杰伦
> > 张学友



### whie循环遍历

(老师说不推荐，有空的时候再来想一下能不能实现...)



### 统计字典元素个数

> ![image-20221127225603736](E:\Typora\Image\image-20221127225603736.png)
>
> ![image-20221127225524384](E:\Typora\Image\image-20221127225524384.png)

> ![image-20221127225555357](E:\Typora\Image\image-20221127225555357.png)



## 字典的方法总览***

> ![image-20221127225631877](E:\Typora\Image\image-20221127225631877.png)



# 数据容器总结***

## 分类对比

> ![image-20221129001124413](E:\Typora\Image\image-20221129001124413.png)

> ![image-20221129001235303](E:\Typora\Image\image-20221129001235303.png)



## 应用场景

> ![image-20221129001351942](E:\Typora\Image\image-20221129001351942.png)



## 数据容器的通用操作

### 遍历

> ![image-20221129123411671](E:\Typora\Image\image-20221129123411671.png)



### 统计(`max()/min()/len()`)

> ![image-20221129123521441](E:\Typora\Image\image-20221129123521441.png)

> 案例：
>
> ![image-20221129125229943](E:\Typora\Image\image-20221129125229943.png)
>
> 
>
> ![image-20221129125208869](E:\Typora\Image\image-20221129125208869.png)

> 输出：
>
> ![image-20221129125333410](E:\Typora\Image\image-20221129125333410.png)
>
> ![image-20221129125345166](E:\Typora\Image\image-20221129125345166.png)
>
> ![image-20221129125404256](E:\Typora\Image\image-20221129125404256.png)



### 容器类型转换

> ![image-20221129142506468](E:\Typora\Image\image-20221129142506468.png)



#### 转换案例

![image-20221129142646174](E:\Typora\Image\image-20221129142646174.png)



#### 转列表`list()`

> 
>
> ![image-20221129142803006](E:\Typora\Image\image-20221129142803006.png)

> ![image-20221129142739522](E:\Typora\Image\image-20221129142739522.png)
>
> 注意：
>
> 1. 字符串转列表时，会将字符串里的每个字符都单独提取出来作为列表的元素
> 2. 字典转列表时，会将`Key`提取出来而抛弃所有的`Value`



#### 转元组`tuple()`

> ![image-20221129164010231](E:\Typora\Image\image-20221129164010231.png)

> ![image-20221129164249831](E:\Typora\Image\image-20221129164249831.png)
>
> 注意：
>
> 1. 字符串转元组时，会将字符串里的每个字符都单独提取出来作为元组的元素
> 2. 字典转元组时，会将`Key`提取出来而抛弃所有的`Value`



#### 转列表`list()`

> ![image-20221129164201336](E:\Typora\Image\image-20221129164201336.png)

> ![image-20221129164228160](E:\Typora\Image\image-20221129164228160.png)
>
> 注意：此时`print`的结果虽然与转换前的结果相同，但是此时的类型都已经是字符串类型`str`



转集合(`set()`)

> ![image-20221129165101374](E:\Typora\Image\image-20221129165101374.png)

> ![image-20221129165136114](E:\Typora\Image\image-20221129165136114.png)
>
> 注意：
>
> 1. 字符串转集合时，会将字符串里的每个字符都单独提取出来作为集合的元素
> 2. 字典转集合时，`Key`和`Value`值都被保存了
> 3. 转换成集合后，集合的数据元素具有无序性
> 4. 如果转换前的数据容器中具有重复元素，则在转换后会去重



#### 转字典`dict()`[无法实现]

由于其他容器缺乏键值对`Key: Value`这个关键要素，所以其他容器类型无法转成字典



### 通用排序

> ![image-20221129165941627](E:\Typora\Image\image-20221129165941627.png)
>
> 第一个参数：传入要排序的数据容器
>
> 第二个参数：默认值`reverse=False`，从小到大进行排序；传入`reverse=True`，从大到小进行排序



> **案例：（正向排序）**
>
> ![image-20221129170831897](E:\Typora\Image\image-20221129170831897.png)

> ![image-20221129170853046](E:\Typora\Image\image-20221129170853046.png)
>
> **注意：**
>
> 1. **排完序后的数据容器都变成了列表类型**
> 2. **字典排序后的`Value`丢失，只保留了`Key`**



> **案例：（反向排序）**
>
> ![image-20221129171302221](E:\Typora\Image\image-20221129171302221.png)

> ![image-20221129171354696](E:\Typora\Image\image-20221129171354696.png)



## 容器通用功能总览***

> ![image-20221129171515230](E:\Typora\Image\image-20221129171515230.png)



## 拓展：字符串比较

> ![image-20221129180445420](E:\Typora\Image\image-20221129180445420.png)
>
> 字符比较是按照字符对应的ASCII码值的大小进行比较的

> 案例：
>
> <img src="E:\Typora\Image\image-20221129180746055.png" alt="image-20221129180746055" style="zoom:50%;" />

> 总结：
>
> <img src="E:\Typora\Image\image-20221129180846239.png" alt="image-20221129180846239" style="zoom:50%;" />





## 习题

> ![image-20221127225903888](E:\Typora\Image\image-20221127225903888.png)





# Python的文件操作

## 文件的编码

> ![image-20221202122939357](E:\Typora\Image\image-20221202122939357.png)



## 文件的操作步骤

1. 打开文件
2. 读写文件
3. 关闭文件

**注意：可以只打开和关闭文件，不进行任何读写**



## 文件的读取



### 文件的打开`open()`

> ![image-20221202163042192](E:\Typora\Image\image-20221202163042192.png)

#### **注意**

1. 如果`name`的参数只传入文件名，那么编译器会认为该文件与当前的`Python`文件同级，所以会再与当前`Python`文件的同个文件夹中搜索并开打该文件
    - 同时要注意`name`参数要以字符串形式传入
    - 另外文件路径复制到`name`参数传入时，斜杠符号要求是`/`正斜杠，反斜杠`\`是不合语法的

2. `mode`的参数传入时可以是用单引号，也可以是双引号

3. `encoding`的参数传入时要严格遵循格式`encoding = "编码格式"`，如`encoding = "UTF-8"`

4. `open`该函数**一经执行**，若文件不存在则会马上创建该文件，前提是打开模式需要选择`w`或``a`



#### 应用案例

1. `open()`所得对象的类型未为`_io.TextIOWrapper`

```python
txt_file = open("C:/Users/win10/Desktop/快捷操作.txt", "r", encoding="UTF-8")
print(type(txt_file))	# 输出：<class '_io.TextIOWrapper'>
```



####  文件打开的模式`mode`

> ![image-20221202163249516](E:\Typora\Image\image-20221202163249516.png)

**注意：`w`模式下，写入的内容会覆盖原有的内容**，这是因为`open()`函数在执行时就会根据`w`模式的选择清空原有文件中的所有内容（若是`a`模式的`open`则不会清空）



### 文件对象的方法

#### `read()`

> ![image-20221202165059772](E:\Typora\Image\image-20221202165059772.png)

##### 注意

1. 该方法括号内传入的数值是用来指定读取数据的**字节数**的
2. `read`方法读取到的内容进行`print`时遇到换行不会打印输出出`'\n'`，而是直接作为一种换行效果输出



##### 应用案例

> **案例1：**`read()`括号内传入参数
>
> ![image-20221202165432244](E:\Typora\Image\image-20221202165432244.png)
>
> 注意：这里10传入数据要求读取10个字节，刚好从文件中读取出来是10个汉字



> **案例2：**`read()`括号内传入参数
>
> **注意：如果代码中`read`方法执行完成后，其光标会停留在读取的最后一个字节处，当下次再次使用该方法时，会从上一次停留的光标处继续往后读取，如下例所示，红色表示第一次使用`read`方法，黄色表示第二次使用`read`方法。**
>
> ![image-20221202170206773](E:\Typora\Image\image-20221202170206773.png)
>
> **如果后续搭配的方法是`readlines`同样会有这种光标停留的效果存在。**如下例所示：
>
> ![image-20221202171024713](E:\Typora\Image\image-20221202171024713.png)
>
> 
>
> 注释第一次`read`方法的调用，程序运行结果：
>
> ![image-20221202170445295](E:\Typora\Image\image-20221202170445295.png)

**注意：以上案例中文本中存在的`\n`都被直接作为换行效果输出了，并没有以字符形式呈现`'\n'`**





#### `readlines()`

> ![image-20221202165128139](E:\Typora\Image\image-20221202165128139.png)



##### 应用案例

> **案例1**
>
> ![image-20221202171302151](E:\Typora\Image\image-20221202171302151.png)
>
> `readlines`方法读取到的**每一行数据**都会作为**列表**的**一个元素**，且换行符`\n`也会被读取，但不再直接呈现换行效果，而是以肉眼可见的字符串`'\n'`进行输出



#### `readline()`

> ![image-20221202171926274](E:\Typora\Image\image-20221202171926274.png)



##### 应用案例

> **案例1**
>
> ![image-20221202172126147](E:\Typora\Image\image-20221202172126147.png)
>
> 注意本案例中对读取到的每一行数据进行输出时，也将读取到的`\n`换行效果呈现了出来



#### for遍历读取文件的每行数据

> ![image-20221202172449587](E:\Typora\Image\image-20221202172449587.png)



##### 应用案例

> **案例1**
>
> ​	![image-20221202172846459](E:\Typora\Image\image-20221202172846459.png)
>
> 程序运行效果如下：
>
> ​	<img src="E:\Typora\Image\image-20221202172930524.png" alt="image-20221202172930524" style="zoom:50%;" />



> **案例2**	
>
> 代码如下：
>
> ​	<img src="E:\Typora\Image\image-20221202172547044.png" alt="image-20221202172547044" style="zoom:50%;" />
>
> 程序运行结果：
>
> ​	<img src="E:\Typora\Image\image-20221202172622791.png" alt="image-20221202172622791" style="zoom:50%;" />
>
> **可以看到此时光标停留现象即使是在for遍历读取操作时仍然存在，也从侧面说明光标停留现象是一视同仁，对于各类方法都是客观存在的**



### 关闭文件对象`close()`

作用：解除Python程序对文件的占用

> ![image-20221202192805390](E:\Typora\Image\image-20221202192805390.png)



### `with open`语法

作用：防止程序员编写程序时没有对打开的文件进行及时的关闭

> ![image-20221202192855761](E:\Typora\Image\image-20221202192855761.png)
>
> 其中第一行代码的创建的对象`f`就相当于前一张图中的第一行代码的`f`



### 文件读取操作汇总***

> ![image-20221202193651727](E:\Typora\Image\image-20221202193651727.png)



## 文件的写入

> ![image-20221203122743809](E:\Typora\Image\image-20221203122743809.png)

> ​	<img src="E:\Typora\Image\image-20221203124334793.png" alt="image-20221203124334793" style="zoom:50%;" />



### 注意

1. 不存在的文件在`open`函数执行时就会在指定的路径下进行创建（且内容为空）

2. **如果`open`的文件已经存在，则当我们以写入模式打开文件时，文件中的内容会被全部清空。**

3. 调用`write`方法写入内容之后不会马上在创建的文件中显示出来（因为程序执行时，`write`只是将待写入的内容加载在缓冲区，还并未写入到磁盘/硬盘的文件当中），它需要我们写入磁盘（可以是使用`flush`方法或者等该文件对象调用`close`方法【close方法内置了`flush`方法】关闭文件之后，写入的内容才会被写入到所创建的文件当中）。如下图案例所示：

    > 
    >
    > ~![image-20221203123324615](E:\Typora\Image\image-20221203123324615.png)
    >
    > ~
    >
    > ![image-20221203123452324](E:\Typora\Image\image-20221203123452324.png)
    >
    > ~
    >
    > ![image-20221203123627595](E:\Typora\Image\image-20221203123627595.png)
    >
    > ~
    >
    > ![image-20221203123750452](E:\Typora\Image\image-20221203123750452.png)



## 文件的追加

> ![image-20221204155008268](E:\Typora\Image\image-20221204155008268.png)
>
> 注意：`open()`时要写`encodin="UTF-8"`

> ​	<img src="E:\Typora\Image\image-20221204160321804.png" alt="image-20221204160321804" style="zoom:50%;" />

### **注意**

1. 选择`a`模式打开一个已经存在的文件，打开时相当于光标停在原文件的最后，当`write`写入时，都是在原文件的最后进行写入操作，即追加。（这一点有别于`w`模式：会把原文件的内容清空，然后从文件的开头开始写入东西）



# Python异常模块与包

## 什么是异常

> ![image-20221205182412861](E:\Typora\Image\image-20221205182412861.png)

> ​	<img src="E:\Typora\Image\image-20221205182725862.png" alt="image-20221205182725862" style="zoom:50%;" />



## 异常演示

> ![image-20221205182537903](E:\Typora\Image\image-20221205182537903.png)

> ![image-20221205182644969](E:\Typora\Image\image-20221205182644969.png)



## 为什么要捕获异常

> ![image-20221205182843160](E:\Typora\Image\image-20221205182843160.png)

> ![image-20221205182949911](E:\Typora\Image\image-20221205182949911.png)



## 捕获常规异常

### 基本语法

> ![image-20221205183049413](E:\Typora\Image\image-20221205183049413.png)

**一定程度上，这种语法也算是捕获所有的异常的语法。**



### 注意***

1. `try`和`except`就像`if`和`else`一样，两个语句只有选择其一去执行；

    但二者又有一定的区别，`try`是先执行了`try`中的代码，然后在这些代码从上往下执行的过程中首次遇到异常之后才会跳转执行`except`，即`try`中的代码必定是执行了一部分的。如下案例：

    > ![image-20221205184327162](E:\Typora\Image\image-20221205184327162.png)
    >
    > 案例中`try`内的代码：出现异常的语句之前的代码都会正常执行，而出现在异常后面的代码将不会执行，并且`try`捕获的是代码中遇到的第一个出现异常的语句：
    >
    > ![image-20221205190203041](E:\Typora\Image\image-20221205190203041.png)
    >
    > 而在第一个异常后面出现的异常由于代码未执行的原因，其异常是不会显现出来的。

​		**也就是说，`try`中的代码在遇到异常的语句之前的部分都是可以执行的**，而出现异常的语句实际上是被执行了的，只是该语句异常没有执行结果。

2. `try`和`except`两个语句是**必须**的，而`else`和`finally`则是非必须的

## 捕获指定异常

### 基本语法

> ![image-20221205183405343](E:\Typora\Image\image-20221205183405343.png)

### 注意

1. 基本语法中的`as`是起名的意思，是给所指定的异常起了个名叫e，这是一个异常对象，可以print进行输出异常信息。如下图

    > ![image-20221205184901976](E:\Typora\Image\image-20221205184901976.png)



### 应用案例

> 案例1：发生的异常没有在指定异常中
>
> ![image-20221205184456923](E:\Typora\Image\image-20221205184456923.png)
>
> 这种情况编译器仍然会报错。



## 捕获多个异常

### 基本语法

> ![image-20221205185014685](E:\Typora\Image\image-20221205185014685.png)



## 捕获所有异常

### 基本语法

> ​	![image-20221205185520456](E:\Typora\Image\image-20221205185520456.png)



### 应用案例

> 案例1
>
> ![image-20221205185559938](E:\Typora\Image\image-20221205185559938.png)

> 案例2
>
> ![image-20221205185621160](E:\Typora\Image\image-20221205185621160.png)

> 案例3
>
> ![image-20221205185640173](E:\Typora\Image\image-20221205185640173.png)

**Exception是最顶级的异常类，其余的异常类（型）都是该类的子类（型）**



## 异常else

### 基本语法

> ![image-20221205190445492](E:\Typora\Image\image-20221205190445492.png)



### 注意

1. `else`是可写可不写的
2. `try`中的代码无异常时则`try`中的代码会正常执行并且还会执行`else`中的代码

> ![image-20221205191006899](E:\Typora\Image\image-20221205191006899.png)



## 异常的`finally`

### 基本语法

> ![image-20221205191213485](E:\Typora\Image\image-20221205191213485.png)



## 异常捕获——总结

> ​	<img src="E:\Typora\Image\image-20221205193939689.png" alt="image-20221205193939689" style="zoom:50%;" />



## 异常的传递

> ![image-20221206184934400](E:\Typora\Image\image-20221206184934400.png)

> ​	<img src="E:\Typora\Image\image-20221206194102549.png" alt="image-20221206194102549" style="zoom:50%;" />
>
> ​	![image-20221206194141538](E:\Typora\Image\image-20221206194141538.png)
>
> 上图所示的执行结果便可以看出异常的传递。
>
> 下面我们在main中对异常进行一个捕获：
>
> ![image-20221206194425282](E:\Typora\Image\image-20221206194425282.png)
>
> 
>
> ​	<img src="E:\Typora\Image\image-20221206194511498.png" alt="image-20221206194511498" style="zoom:50%;" />
>
> 说明我们可以利用异常的传递性，不在异常的直接发生位置进行捕获，而是在其他异常的传递位置进行捕获。
>
> 另外还要注意异常传递的过程中，传递的每个环节中的后续部分的代码都不会再被执行，例如上图中`func2`中对`func1()`的调用就是一个传递的环节，其因为是`func1`异常传递的一个环节，所以`func2`中对func1()调用的后续的代码：`print("func2 结束执行")`就不会再被执行了。**总结来说，一个函数中发生异常就相当于在发生异常的地方执行了一个`return`语句来结束函数。而使用`try`和`except`就可以来使得这个`return`不是直接结束函数，而是跳转到`except`中进行执行，并且不会被传递到上一级的主调函数。**
>
> 而如果`except`中还有发生异常的地方，那就没办法了（除非还有嵌套的`try`和`except`存在），只能是相当于`return`结束函数了，如下例：
>
> - 正常`except`中执行的语句不会出现异常：
>
> ![image-20221206213809457](E:\Typora\Image\image-20221206213809457.png)
>
> 此时`except`后面的`print("func1执行结束")`可以正常执行
>
> - `except`中还有异常：
>
> ![image-20221206214422023](E:\Typora\Image\image-20221206214422023.png)
>
> 上图`try`中发生异常的地方被捕获，不会传递至调用`func1()`的位置，而`except`中出现的异常没有被捕获，且会发生传递，直至`func1()`调用处。
>
> 并且`except`中发生异常后，`func1()`相当于直接`return`，其后面`print("func1执行结束")`没有执行。



### 注意

1. 异常会顺着栈一层层地往下传，直到传递到最高的层级（也即栈底，如上例中的`main`函数），最终在最高的这个层级进行一个捕获。而如果最高的层级中没有`try`，则编译器会直接抛出异常
2. 异常传递的过程中的某个环节如果对异常进行了捕获，则在传递的下一个环节就不会再被捕获到了

> ![image-20221206195550281](E:\Typora\Image\image-20221206195550281.png)
>
> 注意理解和体会上述代码的执行过程。
>
> 值得注意的是`main`中的`except`并没有执行，这因为`main`调用的`fun2`已经对将要传递至`main`的`fun1`中发生的异常`1/0`进行了捕获，所以`main`也就不再能捕获到了。
>
> 捕获的这个过程是一个正常的代码执行过程，所以当`fun2`对`fun1`中的`1/0`的捕获完成后，`fun2`捕获代码以下的代码是可以继续正常执行的，并且执行后还能正常返回`main`（所以以上代码中，只有`fun1`中发生异常以下部分的代码没有执行，其余代码都是正常执行）



3. 如果出现异常的（嵌套）函数没有被执行，则异常不会产生：

> ![image-20221206194941489](E:\Typora\Image\image-20221206194941489.png)



### 总结

1. 异常传递的过程是被调函数向主调函数逐层的传递，每一个函数都将是异常传递的一个环节。
2. 捕获异常时不需要实际地深入到异常发生处进行捕获，只需在异常传递的环节之一进行捕获即可。



# `Python`模块

## 什么是`Python`模块

> ![image-20221206215531929](E:\Typora\Image\image-20221206215531929.png)

## `Python`模块的作用

> ![image-20221206215621013](E:\Typora\Image\image-20221206215621013.png)

## `Python`模块导入语法

> ![image-20221206215743774](E:\Typora\Image\image-20221206215743774.png)
>
> 定义语法中的中括号`[]`表示该内容是可选项，根据需要可写可不写。

### 常见的语法使用形式

> ​	<img src="E:\Typora\Image\image-20221206215811301.png" alt="image-20221206215811301" style="zoom:50%;" />



## `import`模块名

### 基本语法

> ![image-20221206220014087](E:\Typora\Image\image-20221206220014087.png)

### 应用案例

> 案例1：导入
>
> ![image-20221206220103492](E:\Typora\Image\image-20221206220103492.png)
>
> 本质就是导入一个`Python`文件，叫`time.py`
>
> 若要查看`time.py`文件中的内容：
>
> ![image-20221206220259668](E:\Typora\Image\image-20221206220259668.png)
>
> 我们可以按住`Ctrl`键，然后点击`import`的模块（文件）名，如上图所示，即可打开对应的模块：
>
> ![image-20221206220431896](E:\Typora\Image\image-20221206220431896.png)

> 案例2：使用模块中的函数
>
> ​	![image-20221206220736561](E:\Typora\Image\image-20221206220736561.png)
>
> 这个代码的意思即表面`sleep`函数是属于`time`模块的，我们调用的是`time`模块中的`sleep`函数，中间的关键符号就是`.`
>
> 通过`.`就可以访问**模块内全部的功能（类、函数、变量等）**



## `from`导入模块

## `from` 模块名 `import` 功能名

### 基本语法

> ![image-20221206221249261](E:\Typora\Image\image-20221206221249261.png)
>
> 与`import`不同，`import`相当于把整个模块都带过来了，我们通过`.`即可访问模块中所有**功能**。如下图所示，当我们一输入`.`，编译器就自动给我们提示了模块中的**所有功能**：
>
> ​	<img src="E:\Typora\Image\image-20221206221635095.png" alt="image-20221206221635095" style="zoom:50%;" />
>
> 而`from`则可适用于**导入模块中特定的功能**的场景。**注意此时只有`from`导入的功能可以使用，该模块中其他的功能是无法使用的。****

**另外`from`导入时还可以是 `from 模块名 import 功能名1, 功能名2, ......` 这样的多个同时导入**

> ![image-20221208005618692](E:\Typora\Image\image-20221208005618692.png)
>
> 这里演示的是`from 包名 import 模块名1, 模块名2, ......`，但是上面描述的 `from 模块名 import 功能名1, 功能名2, ......` 也是可以的，只要合理，均可嵌套，（应用时再予以摸索使用方法。。。）



### 应用案例

> 案例1：导入`time`模块中的`sleep`函数
>
> ![image-20221206221536944](E:\Typora\Image\image-20221206221536944.png)
>
> 

> 案例2：`from`导入模块中特定的功能
>
> ​	<img src="E:\Typora\Image\image-20221206221938046.png" alt="image-20221206221938046" style="zoom:50%;" />
>
> 可以看到这种导入方式使得我们使用模块中的功能时可以不用再通过`模块名.`的形式，而是可以直接使用。但是如果这种导入方式下，前面再加上`模块名.`也是不可行的：
>
> ​	<img src="E:\Typora\Image\image-20221206234648070.png" alt="image-20221206234648070" style="zoom:50%;" />
>
> 
>
> 如果是`import`导入而不是`from`的方式，则省略`模块名.`是不可行的：
>
> ​	<img src="E:\Typora\Image\image-20221206234514266.png" alt="image-20221206234514266" style="zoom:50%;" />
>
> 
>
> 如果是`from`导入模块特定功能，则不能使用模块的其他未导入的功能：
>
> ​	<img src="E:\Typora\Image\image-20221206235033110.png" alt="image-20221206235033110" style="zoom:50%;" />
>
> ​	<img src="E:\Typora\Image\image-20221206235128984.png" alt="image-20221206235128984" style="zoom:50%;" />
>
> 
>
> 注意上例中实际上的现象实际上是因为`import`是与`模块名.`的调用方式相对应——**使用`import` 模块名时，调用模块功能就需要`模块名.`**
>
> 而`from`则是与省略`模块名.`的调用方式相对应——**使用from进行模块功能导入时，调用模块功能则不能使用`模块名.`的方式**
>
> 如下，我们使用`from`导入`time`的所有功能（而不是`import`）：
>
> ​	<img src="E:\Typora\Image\image-20221207000018072.png" alt="image-20221207000018072" style="zoom:50%;" />
>
> ![image-20221207000042883](E:\Typora\Image\image-20221207000042883.png)
>
> 此时使用`time`模块中的`sleep`省略了`time.`，并且这个省略不可以加回去，即不可以通过`time.sleep()`来调用`sleep`函数，否则会报错如上例。

###  from导入的模块功能重名

> ![image-20221207191739708](E:\Typora\Image\image-20221207191739708.png)
>
> 可以看到：如果当前模块中定义的功能名与`from`导入模块中的功能名相同，则会以就近的为主。
>
> 例如上例中的第2次函数调用，其上方的`def`相当于覆盖了`from`导入的函数，其后续的代码在使用函数名`moduleAdd`调用函数时，调用的均是`def`的函数；而当后续代码再次`from`导入时，则会**覆盖**`def`而使用`from`导入的函数。
>
> 同样的，如果是`from`导入两个模块，而且导入的模块功能名相同，则以最后的导入为主，其同样会**覆盖**以前代码中相同功能名的导入。如下例：
>
> ![image-20221207192703670](E:\Typora\Image\image-20221207192703670.png)
>
> 上例中`from my_moudule2 import my_test`覆盖了`from my_moudule2 import my_test`所以后续代码中调用`my_test`函数时，调用的是`my_moudule2`中的。
>
> 同时我们编译器也是有所提示的：
>
> ​	<img src="E:\Typora\Image\image-20221207193058306.png" alt="image-20221207193058306" style="zoom:50%;" />
>
> 加入调用语句时：
>
> ​	<img src="E:\Typora\Image\image-20221207193006683.png" alt="image-20221207193006683" style="zoom:50%;" />
>
> 可以看到第一个导入语句变灰了，说明其失效了。而且还有一个值得注意的时只有当导入的内容有被使用时，导入的语句才会褪去灰色。



## `as`别名定义

### 作用：`as`给导入的模块或功能起别名

### 基本语法

![image-20221207000902870](E:\Typora\Image\image-20221207000902870.png)



> ​	<img src="E:\Typora\Image\image-20221207000947234.png" alt="image-20221207000947234" style="zoom:50%;" />

### 给`import`导入的模块起别名

> ​	<img src="E:\Typora\Image\image-20221207000502744.png" alt="image-20221207000502744" style="zoom:50%;" />

### 给`from`导入的模块/功能起别名

> ​	<img src="E:\Typora\Image\image-20221207000742679.png" alt="image-20221207000742679" style="zoom:50%;" />



## 模块导入总结

> ​	<img src="E:\Typora\Image\image-20221207001145075.png" alt="image-20221207001145075" style="zoom: 33%;" />



## 自定义模块

### 制作自定义模块

> ![image-20221207155714540](E:\Typora\Image\image-20221207155714540.png)
>
> 导入自定义模块时不局限于`import`导入，也可以是`from`导入，其导入语法和注意事项等都与前面`Python`模块导入的内容一致



### 注意

1. 如果自定义模块中存在测试语句，如下例：

> ​	<img src="E:\Typora\Image\image-20221207193413953.png" alt="image-20221207193413953" style="zoom:50%;" />

则当我们在其他模块中中导入该模块时（可以通过`import`导入，也可以通过`from`导入）会将上例中的用于测试的代码：`test(1, 2)`执行一次：

> ![image-20221207194530375](E:\Typora\Image\image-20221207194530375.png)

所以就是说导入模块的操作实际上会将所被导入的模块中的代码都执行一次。

而我们在开发模块时又避免不了需要这些测试代码，不能去掉，所以为了避免当我们导入模块时无意地将模块中的测试代码执行一遍，我们的解决措施如下一小点所述。

（上述案例中之所以导入特定模块功能的`from`也有执行模块中所有代码的效果是因为`from 模块名`这部分起的作用，可以理解为它把整个模块扫描了一遍才来`import`我们所指定的功能：`from 模块名 import 功能名`）



### 测试模块——`__main__`变量

> ![image-20221207195035930](E:\Typora\Image\image-20221207195035930.png)
>
> 我们将模块中用于测试的代码写在`if __name__ == '__main__':`中时，就只有当我们在当前模块点击运行时，才会执行该判断语句中的内容。
>
> 这是因为当我们在某一个模块/`.py`文件中点击运行时，其内置变量`__name__`会被赋值`__main__`，而如果不是在该模块点击的运行，那么`__name__`就不是`__main__`，所以判断语句体中的代码就不会被执行。所以该操作可以避免`import`导入模块时顺便把该模块中用于测试的代码一并执行。
>
> **注意在`Pycharm`中`if __name__ == '__main__':`的语句可以快捷生成，只要我们输入`main`再敲一个回车，即可立即生成。**



### 限定模块外部可使用的功能——`__all__`变量

> ![image-20221207200034208](E:\Typora\Image\image-20221207200034208.png)
>
> 注意`__all__`变量赋值是必须以列表的形式，列表中的内容是当前模块中的功能名（如函数名、变量名等）
>
> 1. 此时只有`__all__`列表中包含的功能名可以在外部其他模块中被使用，未写进`__all__`的功能名外部无法访问和使用。
> 2. 如果是`__all__`中没有写的功能名，但是我们通过`from 模块名 import 功能名`将`__all__`中未写这个功能名单独导入，这是可以的，并且导入后是可以用的。**也就是说：`__all__`只能限制`from 模块名 import *`的导入。**



### 自定义模块总结

> ​	<img src="E:\Typora\Image\image-20221207201754434.png" alt="image-20221207201754434" style="zoom:50%;" />



## Python包

### 自定包

文件夹中有`__init__.py`即可以标识该文件夹未`Python`包

> ![image-20221208003350989](E:\Typora\Image\image-20221208003350989.png)



### 快速入门

> ![image-20221208003524090](E:\Typora\Image\image-20221208003524090.png)



### 导入包

#### 方式一`import`

> ![image-20221208003651471](E:\Typora\Image\image-20221208003651471.png)
>
> **注意这种方式的语法不能是`import 包名`，必须要具体到包中的模块，即`import 包名.模块名`**！



#### 方式二`from`

##### 1.  `from` 包名 `import` 模块名

> ![image-20221208004010280](E:\Typora\Image\image-20221208004010280.png)
>
> `from`的方式导入包中的模块后，调用模块中的功能时，**不用并且是不能用**`包名.模块名.功能名`的方式，而只能通过`模块名.功能名`来调用模块中的功能！



##### 2. `from` 包名.模块名 `import` 功能名

> ![image-20221208005026046](E:\Typora\Image\image-20221208005026046.png)
>
> **此时也是同理，只能通过功能名的方式调用，其前面不用加上包名和模块名！**



##### 3.`__all__`变量

> ![image-20221208005220122](E:\Typora\Image\image-20221208005220122.png)
>
> 1. `__all__`的定义赋值必须在`__init__.py`文件中进行。
>
> 2. 此时对应的语法是`from 包名 import *`，即其控制的只有`*`。
>
> 3. 即使`__all__`没有包含my_module1，但是可以自己另外包含：
>
>     ​	<img src="E:\Typora\Image\image-20221208005950887.png" alt="image-20221208005950887" style="zoom:67%;" />
>
>     也另一个角度说明了`__all__`变量的限制对`import xxx`的方式无效，只对`*`有效。



### 包的总结

> ​	<img src="E:\Typora\Image\image-20221208010243177.png" alt="image-20221208010243177" style="zoom: 50%;" />



### 安装第三方包

> ![image-20221209002209142](E:\Typora\Image\image-20221209002209142.png)

> ![image-20221209003327605](E:\Typora\Image\image-20221209003327605.png)



#### `cmd`安装第三方包——pip

> ![image-20221209002305673](E:\Typora\Image\image-20221209002305673.png)

> ![image-20221209002430930](E:\Typora\Image\image-20221209002430930.png)



#### Pycharm安装第三方包

> ![image-20221209003115344](E:\Typora\Image\image-20221209003115344.png)
