# 函数

## None类型

- 思考:如果函数没有使用`return`语句返回数据，那么函数有返回值吗?

  ——实际上是:有的。

- Python中有一个特殊的字面量:None，其类型是:`<class 'NoneType'>`无返回值的函数，实际上就是返回了: `None`这个字面量

- `None`表示:空的、无实际意义的意思

- 函数返回的`None`就表示这个函数没有返回什么有意义的内容。也就是返回了空的意思

  <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221118192925622.png" alt="image-20221118192925622" style="zoom:50%;" />

  - **上例中说明None可以程序员手动在函数中写明返回，也可以省略**



- **应用场景：**

  1. **用在函数无返回值上**
  2. **用在if判断上**

  - 在if判断中，None等同于False

  - 一般用在函数中主动返回None，配合if判断做相关处理

    ```python
    def check_age(age):
    	if age > 18:
    		return "SUCCESS"
    	else:
    		return None #该句省略则编译器也会自动返回None
    
    result = check_age(age)
    if not result:	# not表示取反，如若result为None即False，则not result为True
    	print("未成年，不可以进入！")
    ```

  3. **用在声明无内容的变量上**

     定义变量，但暂时不需要变量有具体值，可以用None来代替

     ```Python
     name = None
     ```

  4. **总结**

<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221118194509696.png" alt="image-20221118194509696" style="zoom:50%;" />

## 函数说明文档

> **以下绿色部分为函数说明文档**

![image-20221119185232463](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119185232463.png)

> **鼠标悬停至函数调用处括号（）时，会浮现函数的说明文档，如下图所示**

![image-20221119185216175](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119185216175.png)

## global关键字

- 使用global关键字可以在**函数内部声明变量为全局变量**

```Python
num = 100 # 全局变量

def func1():
    global num  # 说明num是全局变量（而且是前面已经定义的全局变量），此句代码一写，函数里的num和函数外的num就是同一个了
    num = 200   # 将全局变量修改为200,此时会修改上面的全局变量num
    # global num = 200 # 不能这样同时声明num为全局变量又赋值
    print(num)  # 输出200

func1()
print(num)  # 输出200
```

# 数据容器

**一种可以存储多个元素的Python数据类型**

数据容器根据特点的不同，如：

- 是否支持重复元素
- 是否可以修改
- 是否有序

可分为5类，分别是：

> 1. **列表（list）**
>
> 2. **元组（tuple）**
>
> 3. **字符串（str）**
>
> 4. **集合（set）**
>
> 5. **字典（dict）**



## 列表

### **定义语法**

```python
# 字面量
[元素1，元素2，元素3，元素4，元素5...]

# 定义变量
变量名 = [元素1，元素2，元素3，元素4，元素5...]

# 定义空列表
变量名 = []
变量名 = list()
```

列表内的每一个数据，称之为元素

- 以 [ ] 作为标识
- 列表内的每一个元素之间用","逗号隔开



### 列表的特点

![image-20221123235111257](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123235111257.png)



### 列表的下标索引

#### **正向索引**

​	与数组类似，如下图：

![image-20221123205034914](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123205034914.png)



#### **反向索引**

![image-20221123205230318](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123205230318.png)

所以如果要找列表的最后一个元素，则可以直接`list[-1]`



#### **嵌套列表下表索引**

​	类似于二维数组

![image-20221123205352908](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123205352908.png)



- **如果列表索引越界**，如下代码所示：

```python
my_list = [1, 2, 3]
print(mylist[3])
```

则程序会抛异常如下：

> IndexError: list index out of range

![image-20221123205819213](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123205819213.png)





## ***列表的方法总览

![image-20221123234915625](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234915625.png)

### 列表的查询功能（方法）

（类中的函数称为方法）

- 查找指定元素在列表的下标，如果找不到，报错ValueError

语法：

```python
列表.index(要查找的元素)
```

- index()就是列表对象（变量）内置的方法
- 注意index()查找成功后返回值是第一个对应元素值的元素的小标（后续如果还要相同元素值的元素是无法获知的）



### 列表的修改功能

#### 修改特定位置（索引）的元素值

![image-20221123232813859](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123232813859.png)



#### 插入元素

![image-20221123233000702](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233000702.png)



#### 追加元素

1. 单元素追加

    > ![image-20221123233050993](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233050993.png) 	

2. 多元素追加

    > ![image-20221123233352902](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233352902.png)



#### 删除指定下标的元素

> ![image-20221123233548346](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233548346.png)
>

需要注意`pop()`方法实际上是将列表中的元素取出作为返回值（只不过取出的同时会在原列表中删除对应的元素），如下图

> ![image-20221123233915393](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123233915393.png)
>
> 注意如果`pop()`括号中不传入元素的下标参数，则默认`pop`列表的最后一个元素





#### 删除指定元素值的元素

从左到右去搜索对应元素值的元素，第一个找到的元素将被删除

> ![image-20221123234206811](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234206811.png)
>

#### 清空列表

> ![image-20221123234405645](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234405645.png)
>



### 统计元素个数

1. 统计列表中指定元素值的元素个数

> ![image-20221123234520336](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234520336.png)
>

2. 统计列表元素个数


> ![image-20221123234736062](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123234736062.png)
>



### 列表的遍历

遍历：将容器内的元素依次取出，并处理

遍历列表元素的方式（两种）：

### while循环遍历

> ![image-20221124000744858](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124000744858.png)
>



### for循环遍历

> ![image-20221124001048442](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124001048442.png)
>



### while和for循环的对比

> ![image-20221124001306506](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124001306506.png)
>

 

## 元组

元组的理解：只读的列表list

> ![image-20221124182905702](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124182905702.png)

#### **元组内容不可被修改**

> ![image-20221124185707894](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124185707894.png)

#### **但元组中的列表list的内容可以修改**

> ![image-20221124185806502](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124185806502.png)



### 定义语法

```Python
# 定义元组字面量
(元素, 元素,......, 元素)

# 定义元组变量
变量名称 = (元素, 元素,......, 元素)

# 定义空元组
变量名称 = ()		# 方式1
变量名称 = tuple()	# 方式2
```



**注意：**定义只有单个元素的元组时，要在第一个元素后跟一个逗号，否则无法构成单个元素的元组

```python
t1 = ("hello")							  	 # 单个元素，无逗号
print(f"t1的类型是{type(t1)},t1的内容是{t1}")	# 输出：t1的类型是<class 'str'>,t1的内容是hello
```

```python
t2 = ("hello", )							 # 单个元素，有逗号
print(f"t2的类型是{type(t2)},t2的内容是{t2}")	# 输出：t2的类型是<class 'tuple'>,t2的内容是('hello',)
```



#### 嵌套定义

如下：

> ![image-20221124184709214](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124184709214.png)

其输出结果是：

> ![image-20221124184741137](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124184741137.png)



### 元组的特点

> ![image-20221124185959462](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124185959462.png)

> ![image-20221124190344660](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124190344660.png)



### 下标索引

> ![image-20221124184846129](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124184846129.png)

同样的元组也可以通过[-1]这样的反向索引



### 元组的方法总览

> ![image-20221124184951846](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124184951846.png)
>
> 



### 元组的遍历

> ![image-20221124185252456](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124185252456.png)
>
>  



## 字符串

> ![image-20221124191417166](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124191417166.png)



### 下标索引

> ![image-20221124191455879](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124191455879.png)



### 字符串内容无法修改

> ![image-20221124191829543](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124191829543.png)

> ![image-20221124191642163](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124191642163.png)

**如果必须要做，只能得到一个新的字符串，旧的字符串是无法修改的！！！**



### 字符串的特点

> ![image-20221124195111099](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124195111099.png)





### ***字符串的方法总览

![image-20221124194843614](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124194843614.png)





### 字符串查找功能(index)

> ![image-20221124192008237](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124192008237.png)

注意`index()`返回的是待查找字符串的第一个匹配字符在字符串中的位置（空格也算一个字符）

```python
# 如果字符串是中文也是一样
t1 = "我是 周杰伦"
print(t1.index("周杰伦"))	# 输出3
```



### 字符串的替换(replace)

> ![image-20221124192420603](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124192420603.png)

而且要注意，如果字符串里如果有多个重复的字符串1，那么这些所有的字符串1都会被替换成字符串2

并且，字符串在执行`replace()`之后本身是没有发生变化的：

```python
string = "itheima and itcast"
newString = string.replace("it", "程序")
print(newString)	# 输出：程序heima and 程序cast
print(string)		# 输出：itheima and itcast
```





### 字符串的分割(split)

#### **字符串经分割之后得到的是列表**

> ![image-20221124193015664](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193015664.png)

> ![image-20221124193146862](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193146862.png)
>
> 输出结果：
>
> ![image-20221124193224338](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193224338.png)

> ![image-20221124193259345](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193259345.png)

注意`split()`的括号中如果不填入参数，则**默认以空格作为分割符**



### 字符串的规整操作(strip)

strip()中若不填入**规整符**，**默认规整空格和回车换行符**（即去掉前后空格和换行符）

#### 无参规整

> ![image-20221124193559085](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193559085.png)

#### 有参规整

> ![image-20221124193827724](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124193827724.png)
>
> **此处应注意**虽然我们要求去掉的是首尾的"12"，即strip("12")，但strip()方法在执行时相当于把"12"，拆分成了"1"、"2"，所以这就导致只要首尾有符合的，就会被去掉，所以可以看到该例字符串尾部的21也被去掉了





### 字符串的统计(count、len)

- **count()方法**

> ![image-20221124194515646](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124194515646.png)
>
> 字符串中的`count()`方法不仅可以统计单个元素，还可以统计子串



- **len()函数**

> ![image-20221124194734759](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124194734759.png)





### 字符串的遍历

![image-20221124194940253](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124194940253.png)





## 序列

> ![image-20221125190721509](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125190721509.png)



### 序列的常用操作——切片

> 示意图：
>
> ![image-20221125190907797](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125190907797.png)
>
> 从大序列里面取出一个小序列



#### 操作语法

> ![image-20221125193320986](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125193320986.png)

> ![image-20221125191129368](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125191129368.png)



#### **注意**

1. **切片操作不会影响原序列，而是会得到一个新的序列（列表、元组、字符串）**

2.  **切片操作之后所获得的序列类型与原来的序列类型相同（列表、元组、字符串）**



#### 省略步长的情况

> ![image-20221125192330508](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192330508.png)

> ![image-20221125192809918](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192809918.png)



#### 省略起始下标和结束下标的情况

> ![image-20221125192422698](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192422698.png)Q

> ![image-20221125192859968](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192859968.png)



#### 省略起始下标，结束下标和步长的情况

注意此时方括号[]内要有冒号":"

> ![image-20221125191814966](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125191814966.png)

> ![image-20221125192837072](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192837072.png)



#### 步长为-1，省略起始下标和结束下标的情况

步长为-1时，序列的切片会从后往前进行

> ![image-20221125192522201](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192522201.png)

> ![image-20221125192920247](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125192920247.png)



#### 步长为-1，不省略起始下标和结束下标的情况

> ![image-20221125193036439](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125193036439.png)

> ![image-20221125193109309](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125193109309.png)



#### 连续切片操作

> ![image-20221125194206124](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194206124.png)

> ![image-20221125194214608](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194214608.png)



#### 综合的一个方法/操作使用案例

> ![image-20221125194600078](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194600078.png)

> ![image-20221125194543773](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194543773.png)

> ![image-20221125194614188](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221125194614188.png)



## 集合(`set`)

### 为什么要使用集合

> ![image-20221126193801283](E:\Typora\Image\image-20221126193801283.png)



### 集合的特点

> ![image-20221126202030575](E:\Typora\Image\image-20221126202030575.png)



### 定义语法

> <img src="E:\Typora\Image\image-20221126193942251.png" alt="image-20221126193942251" style="zoom:50%;" />



**注意：定义空集合时不要用下面的语法**

```python
my_Set = {}
```

这样一来我们执行下面的程序时:

```python
print(my_Set)		# 输出：{}
print(type(my_Set))	# 输出：<class 'dict'>
```

可以看到此时`my_Set`并不是`set`类型，而是`dict`字典类型



### 集合具有去重和无序特性

> ![image-20221126194552017](E:\Typora\Image\image-20221126194552017.png)

上面的代码中我们可以看到，`my_set`中重复的元素被自动删除了，并且元素是无序的（我们定义该集合的时候第一个元素是`'传智教育'`，但是当我们print输出的时候第一个元素却变成了`'黑马程序员'`）



### 集合不是序列，不可通过下标访问



### 集合的修改

#### 添加新元素(`add(元素值)`)

> ![image-20221126195046760](E:\Typora\Image\image-20221126195046760.png)

#### 移除元素(`remove(元素值)`)

> ![image-20221126195342746](E:\Typora\Image\image-20221126195342746.png)

#### 随机取出元素(`pop()`)

> ![image-20221126195457675](E:\Typora\Image\image-20221126195457675.png)

该功能注意与列表的`pop()`进行区分：

列表的`pop()`方法是可以在括号内传入指定的元素下标进行元素取出操作的，但是集合由于无序，即没有下标，所以无法指定下标，所以集合中的`pop()`方法只能**随机取**集合中的一个元素出来。比如以下代码：

```python
my_Set = {"我", "是", "南"}
print(my_Set.pop())
```

> 第1次执行时的结果是：是
>
> 第2次执行时的结果是：是
>
> 第3次执行时的结果是：我
>
> 第4次执行时的结果是：我
>
> 第5次执行时的结果是：我
>
> 第6次执行时的结果是：是
>
> 第7次执行时的结果是：我	
>
> 第8次执行时的结果是：我
>
> 第9次执行时的结果是：我
>
> 第10次执行时的结果是：南

可以见得其随机性。



#### 清空集合(`clear()`)

> ![image-20221126200551179](E:\Typora\Image\image-20221126200551179.png)



#### 取出两个集合的差集(`difference`)

> ![image-20221126200804905](E:\Typora\Image\image-20221126200804905.png)



#### 消除两个集合的差集(`difference_update`)

> ![image-20221126201312944](E:\Typora\Image\image-20221126201312944.png)



#### 两个集合合并(`union`)

> ![image-20221126201419779](E:\Typora\Image\image-20221126201419779.png)



### 集合元素个数统计(`len()`)

> ![image-20221126201643269](E:\Typora\Image\image-20221126201643269.png)



### 集合的遍历

> ![image-20221126201750231](E:\Typora\Image\image-20221126201750231.png)
>
> 代码运行结果：
>
> ![image-20221126201829214](E:\Typora\Image\image-20221126201829214.png)



### 集合方法的方法总览

> ![image-20221126201943308](E:\Typora\Image\image-20221126201943308.png)



# 字典(`dict`)

## 为什么使用字典

> ![image-20221127213359109](E:\Typora\Image\image-20221127213359109.png)

> ![image-20221127213423941](E:\Typora\Image\image-20221127213423941.png)

> ![image-20221127213507698](E:\Typora\Image\image-20221127213507698.png)

## 使用字典的原因

可以使用字典，实现Key取出Value的操作



## 定义语法

> ![image-20221127213705894](E:\Typora\Image\image-20221127213705894.png)



## 字典的特点

> ![image-20221127225750345](E:\Typora\Image\image-20221127225750345.png)



## 注意事项

### 不能定义重复的`Key`

> ![image-20221127214755617](E:\Typora\Image\image-20221127214755617.png)

定义重复`Key`的会只有一个`Key`保存，且是最后一个**（这里是因为较后面的字典元素覆盖了前面的字典元素）**。

理解：相当于我们的字典当中，“字”只会有一个。



### 字典没有下标索引

字典(`dict`)和集合一样(`set`)，不可用使用下标索引。

但字典可以通过`Key`值来取得对应的`Value`值



### `Key`的类型不能是字典

字典的`Key`可以是除**了字典之外**的任何类型，`Value`可以是任何类型



### for循环遍历字典时，遍历变量得到的是每个字典元素的Key，而非每个字典元素

```python
my_dict = {"梁深南": 96, "周杰伦": 98, "张学友": 88}
for i in my_dict:	# i是所谓的遍历变量
    print(i)
```

输出结果：

> 梁深南
> 周杰伦
> 张学友



### 字典可能是有序的...

> ![image-20221127223507589](E:\Typora\Image\image-20221127223507589.png)

（还不太确定...）如果真的是有序的，那么就与集合有区别了，不过好像有序无序都没啥区别，因为没有办法用下标索引，只能通过`Key`索引，所以在这个角度来看，有序无序显得不是很有区分的必要





## 字典数据(`Value`)的获取

**与下标索引的方式非常类似**，但是`[]`中填入的是`Key`，不能是下标值

> ![image-20221127221017385](E:\Typora\Image\image-20221127221017385.png)

理解：汉字字典中找到某一个字(`Key`)就能看到其对应的含义(`Value`)





## 字典的嵌套

### 定义

> ![image-20221127222159546](E:\Typora\Image\image-20221127222159546.png)

> ![image-20221127222322422](E:\Typora\Image\image-20221127222322422.png)

 

### 使用

> ![image-20221127222548631](E:\Typora\Image\image-20221127222548631.png)



## 字典的修改

### 新增元素(`字典[Key] = Value`)

> ![image-20221127222915059](E:\Typora\Image\image-20221127222915059.png)
>
> 这个语法的使用前提是`[]`中输入的`Key`是原字典中不存在的



### 更新元素(`字典[Key] = Value`)

语法与**新增元素**的**语法相同**

> ![image-20221127223152677](E:\Typora\Image\image-20221127223152677.png)



### 删除元素(`pop(Key)`)

> ![image-20221127223751779](E:\Typora\Image\image-20221127223751779.png)
>
> 注意`pop(Key)`返回值是`Key`对应的`Value`值



### 清空元素(`字典.clear()`)

> ![image-20221127224127869](E:\Typora\Image\image-20221127224127869.png)



## 获取字典全部Key(`字典.keys()`)

> ![image-20221127224254254](E:\Typora\Image\image-20221127224254254.png)

理解：获取中华字典中全部的字

**用途：实现字典的遍历**



## 遍历字典

### for循环遍历方式一

> ![image-20221127224533173](E:\Typora\Image\image-20221127224533173.png)

> ![image-20221127224608764](E:\Typora\Image\image-20221127224608764.png)



### for循环遍历方式二

> ![image-20221127224721942](E:\Typora\Image\image-20221127224721942.png)
>
> `my_dict`虽然是字典类型，但此时key每一次取出来的都会是`my_dict`中的`key`而已，不会是字典元素
>
> 比如下面的代码：
>
> ```python
> my_dict = {"梁深南": 96, "周杰伦": 98, "张学友": 88}
> for i in my_dict:
>     print(i)
> ```
>
> 其输出结果为：
>
> > 梁深南
> > 周杰伦
> > 张学友



### whie循环遍历

(老师说不推荐，有空的时候再来想一下能不能实现...)



### 统计字典元素个数

> ![image-20221127225603736](E:\Typora\Image\image-20221127225603736.png)
>
> ![image-20221127225524384](E:\Typora\Image\image-20221127225524384.png)

> ![image-20221127225555357](E:\Typora\Image\image-20221127225555357.png)



## 字典的方法总览***

> ![image-20221127225631877](E:\Typora\Image\image-20221127225631877.png)



## 习题：

> ![image-20221127225903888](E:\Typora\Image\image-20221127225903888.png)
